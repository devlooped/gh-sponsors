using System.Diagnostics.CodeAnalysis;
using System.IdentityModel.Tokens.Jwt;
using System.Numerics;
using System.Security.Claims;
using System.Security.Cryptography;
using System.Text;
using Microsoft.IdentityModel.Tokens;

namespace Devlooped.SponsorLink;

/// <summary>
/// Represents a manifest of sponsorship claims.
/// </summary>
public class Manifest
{
    readonly string salt;
    readonly HashSet<string> linked;

    /// <summary>
    /// Status of a manifest.
    /// </summary>
    public enum Status
    {
        /// <summary>
        /// The manifest is expired and needs re-issuing via <c>gh sponsors sync</c>.
        /// </summary>
        Expired,
        /// <summary>
        /// The manifest is invalid and needs re-issuing via <c>gh sponsors sync</c>.
        /// </summary>
        Invalid,
        /// <summary>
        /// The manifest was not found at all. Requires running <c>gh sponsors sync</c>.
        /// </summary>
        NotFound,
        /// <summary>
        /// The manifest was found and is valid.
        /// </summary>
        Verified,
    }

    static Manifest()
    {
        PublicKey = RSA.Create();
        using var stream = typeof(Manifest).Assembly
            .GetManifestResourceStream("Devlooped.SponsorLink.SponsorLink.pub");

        var mem = new MemoryStream((int)stream!.Length);
        stream.CopyTo(mem);

        PublicKey.ImportRSAPublicKey(mem.ToArray(), out _);
    }

    Manifest(string jwt, string salt, ClaimsPrincipal principal)
        : this(jwt, salt, new HashSet<string>(principal.FindAll("hash").Select(x => x.Value))) { }

    Manifest(string jwt, string salt, HashSet<string> linked)
        => (Token, this.salt, this.linked) = (jwt, salt, linked);

    /// <summary>
    /// The public key used to validate manifests signed with the default private key.
    /// </summary>
    public static RSA PublicKey { get; }

    /// <summary>
    /// Checks whether the given email is sponsoring the given sponsorable account.
    /// </summary>
    public bool IsSponsoring(string email, string sponsorable)
        => linked.Contains(
                Convert.ToBase64String(
                    SHA256.HashData(Encoding.UTF8.GetBytes(salt + email + sponsorable)))) ||
            (email.IndexOf('@') is int index && index > 0 &&
             linked.Contains(
                Convert.ToBase64String(
                    SHA256.HashData(Encoding.UTF8.GetBytes(salt + email[(index + 1)..] + sponsorable)))));

    /// <summary>
    /// Gets the expiration date of the current manifest.
    /// </summary>
    public DateTime ExpiresAt { get; private set; }

    /// <summary>
    /// Hashes contained in the manifest.
    /// </summary>
    public IEnumerable<string> Hashes => linked;

    /// <summary>
    /// The JWT token representing the manifest.
    /// </summary>
    public string Token { get; }

    /// <summary>
    /// Tries to read the default manifest.
    /// </summary>
    /// <param name="manifest">The read manifest if present and valid.</param>
    /// <returns>The manifest status.</returns>
    public static Status TryRead([NotNullWhen(true)] out Manifest? manifest)
    {
        manifest = default;

        var jwt = Environment.GetEnvironmentVariable("SPONSORLINK_MANIFEST", EnvironmentVariableTarget.User);
        var salt = Environment.GetEnvironmentVariable("SPONSORLINK_INSTALLATION", EnvironmentVariableTarget.User);
        // We need both values in order to use the manifest at all. 
        // These are generated by the gh sponsors sync command.
        if (string.IsNullOrEmpty(jwt) || string.IsNullOrEmpty(salt))
            return Status.NotFound;

        try
        {
            manifest = Read(jwt, salt);
            return Status.Verified;
        }
        catch (SecurityTokenExpiredException)
        {
            return Status.Expired;
        }
        catch (SecurityTokenException)
        {
            return Status.Invalid;
        }
    }

    /// <summary>
    /// Reads a manifest and validates it using the embedded public key.
    /// </summary>
    public static Manifest Read(string token) => Read(token, Session.InstallationId, PublicKey);

    /// <summary>
    /// Reads a manifest and validates it using the embedded public key.
    /// </summary>
    public static Manifest Read(string token, string salt) => Read(token, salt, PublicKey);

    /// <summary>
    /// Reads a manifest and validates it using the given public key.
    /// </summary>
    internal static Manifest Read(string token, string salt, RSA rsa)
    {
        var validation = new TokenValidationParameters
        {
            RequireExpirationTime = true,
            ValidAudience = "SponsorLink",
            ValidIssuer = "Devlooped",
            IssuerSigningKey = new RsaSecurityKey(rsa)
        };

        var principal = new JwtSecurityTokenHandler().ValidateToken(token, validation, out var securityToken);

        return new Manifest(token, salt, principal)
        {
            ExpiresAt = securityToken.ValidTo
        };
    }

    /// <summary>
    /// Creates an unsigned manifest, to be used to request a signed one.
    /// </summary>
    /// <param name="salt">A random string used to salt the values to be hashed.</param>
    /// <param name="user">The identifier of the manifest owner.</param>
    /// <param name="emails">Email(s) of the manifest owner.</param>
    /// <param name="domains">Verified organization domains the user belongs to.</param>
    /// <param name="sponsoring">The accounts the manifest owner is sponsoring.</param>
    public static Manifest Create(string salt, string user, string[] emails, string[] domains, string[] sponsoring)
    {
        var linked = new HashSet<string>();

        foreach (var sponsorable in sponsoring)
        {
            foreach (var email in emails)
            {
                var data = SHA256.HashData(Encoding.UTF8.GetBytes(salt + email + sponsorable));
                var hash = Convert.ToBase64String(data);

                linked.Add(hash);
            }

            foreach (var domain in domains)
            {
                var data = SHA256.HashData(Encoding.UTF8.GetBytes(salt + domain + sponsorable));
                var hash = Convert.ToBase64String(data);

                linked.Add(hash);
            }
        }

        var token = new JwtSecurityToken(
            issuer: "Devlooped",
            audience: "SponsorLink",
            claims: new[] { new Claim("sub", user) }.Concat(linked.Select(x => new Claim("hash", x))),
            // Expire at the end of the month
            expires: new DateTime(DateTime.Today.Year, DateTime.Today.Month + 1, 1, 0, 0, 0, DateTimeKind.Utc));

        // Serialize the token and return as a string
        var jwt = new JwtSecurityTokenHandler().WriteToken(token);

        return new Manifest(jwt, salt, linked)
        {
            ExpiresAt = token.ValidTo
        };
    }

    /// <summary>
    /// Signs the manifes with the given key and returns the new JWT.
    /// </summary>
    /// <param name="key">The RSA key to use for signing.</param>
    public string Sign(RSA key)
    {
        var token = new JwtSecurityTokenHandler().ReadJwtToken(Token);
        var signing = new SigningCredentials(new RsaSecurityKey(key), SecurityAlgorithms.RsaSha256);

        var jwt = new JwtSecurityToken(
            issuer: token.Issuer,
            audience: token.Audiences.First(),
            claims: token.Claims,
            expires: token.ValidTo,
            signingCredentials: signing);

        return new JwtSecurityTokenHandler().WriteToken(jwt);
    }
}
