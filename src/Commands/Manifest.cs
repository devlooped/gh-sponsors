using System.Diagnostics.CodeAnalysis;
using System.IdentityModel.Tokens.Jwt;
using System.Numerics;
using System.Security.Claims;
using System.Security.Cryptography;
using System.Text;
using Microsoft.IdentityModel.Tokens;

namespace Devlooped.SponsorLink;

/// <summary>
/// Represents a manifest of sponsorship claims.
/// </summary>
public class Manifest
{
    readonly string salt;
    readonly HashSet<string> linked;

    /// <summary>
    /// Status of a manifest.
    /// </summary>
    public enum Status
    {
        /// <summary>
        /// The manifest is expired and needs re-issuing via <c>gh sponsors sync</c>.
        /// </summary>
        Expired,
        /// <summary>
        /// The manifest is invalid and needs re-issuing via <c>gh sponsors sync</c>.
        /// </summary>
        Invalid,
        /// <summary>
        /// The manifest was not found at all. Requires running <c>gh sponsors sync</c>.
        /// </summary>
        NotFound,
        /// <summary>
        /// The manifest was found and is valid.
        /// </summary>
        Verified,
    }

    static Manifest()
    {
        PublicKey = RSA.Create();
        using var stream = typeof(Manifest).Assembly
            .GetManifestResourceStream("Devlooped.SponsorLink.SponsorLink.pub");

        var mem = new MemoryStream((int)stream!.Length);
        stream.CopyTo(mem);

        PublicKey.ImportRSAPublicKey(mem.ToArray(), out _);
    }

    Manifest(string jwt, string salt, ClaimsPrincipal principal)
        : this(jwt, salt, new HashSet<string>(principal.FindAll("hash").Select(x => x.Value))) { }

    Manifest(string jwt, string salt, HashSet<string> linked)
        => (Token, this.salt, this.linked) = (jwt, salt, linked);

    /// <summary>
    /// The public key used to validate manifests signed with the default private key.
    /// </summary>
    public static RSA PublicKey { get; }

    /// <summary>
    /// Checks whether the given email is sponsoring the given sponsorable account.
    /// </summary>
    public bool IsSponsoring(string email, string sponsorable)
        => linked.Contains(
                Base62.Encode(BigInteger.Abs(new BigInteger(
                    SHA256.HashData(Encoding.UTF8.GetBytes(salt + email + sponsorable)))))) ||
            (email.IndexOf('@') is int index && index > 0 &&
             linked.Contains(
                Base62.Encode(BigInteger.Abs(new BigInteger(
                    SHA256.HashData(Encoding.UTF8.GetBytes(salt + email[(index + 1)..] + sponsorable)))))));

    /// <summary>
    /// Hashes contained in the manifest.
    /// </summary>
    public IEnumerable<string> Hashes => linked;

    /// <summary>
    /// The JWT token representing the manifest.
    /// </summary>
    public string Token { get; }

    /// <summary>
    /// Tries to read the default manifest.
    /// </summary>
    /// <param name="manifest">The read manifest if present and valid.</param>
    /// <returns>The manifest status.</returns>
    public static Status TryRead([NotNullWhen(true)] out Manifest? manifest)
    {
        manifest = default;

        var jwt = Environment.GetEnvironmentVariable("SPONSORLINK_MANIFEST", EnvironmentVariableTarget.User);
        var salt = Environment.GetEnvironmentVariable("SPONSORLINK_INSTALLATION", EnvironmentVariableTarget.User);
        // We need both values in order to use the manifest at all. 
        // These are generated by the gh sponsors sync command.
        if (string.IsNullOrEmpty(jwt) || string.IsNullOrEmpty(salt))
            return Status.NotFound;

        try
        {
            manifest = Read(jwt, salt);
            return Status.Verified;
        }
        catch (SecurityTokenExpiredException)
        {
            return Status.Expired;
        }
        catch (SecurityTokenException)
        {
            return Status.Invalid;
        }
    }

    /// <summary>
    /// Reads a manifest and validates it using the embedded public key.
    /// </summary>
    public static Manifest Read(string token) => Read(token, Session.InstallationId, PublicKey);

    /// <summary>
    /// Reads a manifest and validates it using the embedded public key.
    /// </summary>
    public static Manifest Read(string token, string salt) => Read(token, salt, PublicKey);

    /// <summary>
    /// Reads a manifest and validates it using the given public key.
    /// </summary>
    internal static Manifest Read(string token, string salt, RSA rsa)
    {
        var validation = new TokenValidationParameters
        {
            RequireExpirationTime = true,
            ValidAudience = "SponsorLink",
            ValidIssuer = "Devlooped",
            IssuerSigningKey = new RsaSecurityKey(rsa)
        };

        var principal = new JwtSecurityTokenHandler().ValidateToken(token, validation, out var _);

        return new Manifest(token, salt, principal);
    }

    /// <summary>
    /// Creates an unsigned manifest, to be used to request a signed one.
    /// </summary>
    /// <param name="salt">A random string used to salt the values to be hashed.</param>
    /// <param name="user">The identifier of the manifest owner.</param>
    /// <param name="emails">Email(s) of the manifest owner.</param>
    /// <param name="domains">Verified organization domains the user belongs to.</param>
    /// <param name="sponsoring">The accounts the manifest owner is sponsoring.</param>
    public static Manifest Create(string salt, string user, string[] emails, string[] domains, string[] sponsoring)
    {
        var linked = new HashSet<string>();

        foreach (var sponsorable in sponsoring)
        {
            foreach (var email in emails)
            {
                var data = SHA256.HashData(Encoding.UTF8.GetBytes(salt + email + sponsorable));
                var hash = Base62.Encode(BigInteger.Abs(new BigInteger(data)));

                linked.Add(hash);
            }

            foreach (var domain in domains)
            {
                var data = SHA256.HashData(Encoding.UTF8.GetBytes(salt + domain + sponsorable));
                var hash = Base62.Encode(BigInteger.Abs(new BigInteger(data)));

                linked.Add(hash);
            }
        }

        var token = new JwtSecurityToken(
            issuer: "Devlooped",
            audience: "SponsorLink",
            claims: new[] { new Claim("sub", user) }.Concat(linked.Select(x => new Claim("hash", x))),
            // Expire at the end of the month
            expires: new DateTime(DateTime.Today.Year, DateTime.Today.Month + 1, 1, 0, 0, 0, DateTimeKind.Utc));

        // Serialize the token and return as a string
        var jwt = new JwtSecurityTokenHandler().WriteToken(token);

        return new Manifest(jwt, salt, linked);
    }

    /// <summary>
    /// Signs the manifes with the given key and returns the new JWT.
    /// </summary>
    /// <param name="key">The RSA key to use for signing.</param>
    public string Sign(RSA key)
    {
        var token = new JwtSecurityTokenHandler().ReadJwtToken(Token);
        var signing = new SigningCredentials(new RsaSecurityKey(key), SecurityAlgorithms.RsaSha256);

        var jwt = new JwtSecurityToken(
            issuer: token.Issuer,
            audience: token.Audiences.First(),
            claims: token.Claims,
            expires: token.ValidTo,
            signingCredentials: signing);

        return new JwtSecurityTokenHandler().WriteToken(jwt);
    }

    /// <summary>
    /// Inspired in a bunch of searches, samples and snippets on various languages 
    /// and blogs and what-not on doing URL shortering :), heavily tweaked to make 
    /// it fully idiomatic in C#.
    /// </summary>
    static partial class Base62
    {
        /// <summary>
        /// Encodes a numeric value into a base62 string.
        /// </summary>
        public static string Encode(BigInteger value)
        {
            // TODO: I'm almost sure there's a more succint way 
            // of doing this with LINQ and Aggregate, but just 
            // can't figure it out...
            var sb = new StringBuilder();

            while (value != 0)
            {
                sb = sb.Append(ToBase62(value % 62));
                value /= 62;
            }

            return new string(sb.ToString().Reverse().ToArray());
        }

        /// <summary>
        /// Decodes a base62 string into its original numeric value.
        /// </summary>
        public static BigInteger Decode(string value)
            => value.Aggregate(new BigInteger(0), (current, c) => current * 62 + FromBase62(c));

        static char ToBase62(BigInteger d) => d switch
        {
            BigInteger v when v < 10 => (char)('0' + d),
            BigInteger v when v < 36 => (char)('A' + d - 10),
            BigInteger v when v < 62 => (char)('a' + d - 36),
            _ => throw new ArgumentException($"Cannot encode digit {d} to base 62.", nameof(d)),
        };

        static BigInteger FromBase62(char c) => c switch
        {
            char v when c >= 'a' && v <= 'z' => 36 + c - 'a',
            char v when c >= 'A' && v <= 'Z' => 10 + c - 'A',
            char v when c >= '0' && v <= '9' => c - '0',
            _ => throw new ArgumentException($"Cannot decode char '{c}' from base 62.", nameof(c)),
        };
    }
}
